# JsonSaveManager 使用文档

## 一、概述

`JsonSaveManager` 是一个 **基于 Newtonsoft Json 的通用持久化数据管理器**，用于在 Unity 项目中：

* 将运行时数据序列化为 **JSON 文件**
* 将 JSON 文件反序列化回数据对象
* 存档文件统一存放在 `Application.persistentDataPath`
* **通过 `[SaveKey] Attribute 绑定存档文件名**，避免硬编码字符串

### 设计原则

* **类型安全**：不依赖字符串文件名
* **稳定性**：类名重构不影响存档
* **解耦**：业务层不关心文件路径与命名规则
* **工程级**：适合中大型项目长期维护

---

## 二、使用前置条件

### 1️⃣ 引入依赖

* Unity Package：`com.unity.nuget.newtonsoft-json`
* 命名空间：

  ```csharp
  using GanFramework.Core.Data.Persistent;
  ```

---

### 2️⃣ 数据类必须标记 `[SaveKey]`

**所有需要被持久化的数据类型，必须声明 `SaveKey` Attribute。**

```csharp
[SaveKey("player")]
public class PlayerData
{
    public int level;
    public float hp;
}
```

> ⚠️ 若未标记 `[SaveKey]`，调用保存 / 读取方法时会抛出异常。

---

## 三、基本用法

### 1️⃣ 保存数据

```csharp
PlayerData data = new PlayerData
{
    level = 10,
    hp = 95f
};

JsonSaveManager.Save(data);
```

#### 保存结果

* 文件路径：

  ```
  Application.persistentDataPath/player.json
  ```
* 文件名来源：

  ```
  SaveKey("player") → player.json
  ```

---

### 2️⃣ 读取数据

```csharp
PlayerData data = JsonSaveManager.Load<PlayerData>();

if (data != null)
{
    Debug.Log($"Level: {data.level}, HP: {data.hp}");
}
```

* 若存档文件不存在：

    * 返回 `default(T)`（引用类型为 `null`）

---

### 3️⃣ 判断存档是否存在

```csharp
bool exists = JsonSaveManager.Exists<PlayerData>();

if (exists)
{
    Debug.Log("玩家存档存在");
}
```

---

### 4️⃣ 删除存档

```csharp
JsonSaveManager.Delete<PlayerData>();
```

* 删除对应 `SaveKey` 的 JSON 文件
* 删除成功后会输出调试日志

---

## 四、推荐的使用模式

### 模块化存档（推荐）

为不同系统拆分不同的数据类型：

```csharp
[SaveKey("player")]
public class PlayerData { }

[SaveKey("world")]
public class WorldData { }

[SaveKey("settings")]
public class SettingsData { }
```

```text
persistentDataPath/
 ├─ player.json
 ├─ world.json
 └─ settings.json
```

业务逻辑只关心“存什么”，而不关心“怎么存”。

---

## 五、序列化注意事项

### ✔ 推荐保存的内容

* 基础类型（int / float / bool）
* List / Dictionary
* 纯数据类（POCO）

### ❌ 不推荐保存的内容

* `MonoBehaviour`
* `GameObject`
* `Transform`
* Unity Engine 对象引用

应使用 **ID / 索引 / 状态值** 替代引用。

---

## 六、Json 序列化配置说明

当前使用的 `JsonSerializerSettings`：

```csharp
Formatting = Formatting.Indented
ReferenceLoopHandling = ReferenceLoopHandling.Ignore
```

含义：

* **Indented**：提高 JSON 可读性，方便调试与手工修改
* **Ignore**：忽略循环引用，避免运行时异常

---

## 七、错误与异常说明

### 1️⃣ data 为 null

```csharp
JsonSaveManager.Save(null);
```

* 抛出 `ArgumentNullException`

---

### 2️⃣ 类型未标记 `[SaveKey]`

```csharp
public class NoSaveKeyData { }
```

* 调用 Save / Load 时会抛出异常
* 属于**配置错误**，应在开发阶段修复

---

## 八、典型使用场景

* 单机游戏存档
* Roguelike / 卡牌局内状态
* 玩家长期成长数据
* 本地设置（音量 / 画质 / 操作）

---

## 九、最佳实践建议

* 一个数据类对应一个存档文件
* `[SaveKey]` 命名使用 **稳定、语义化的字符串**
* 不使用类名作为存档标识
* 存档数据与运行时逻辑解耦

---

## 十、示例：完整使用流程

```csharp
if (!JsonSaveManager.Exists<PlayerData>())
{
    JsonSaveManager.Save(new PlayerData { level = 1, hp = 100 });
}

PlayerData data = JsonSaveManager.Load<PlayerData>();
data.level++;

JsonSaveManager.Save(data);
```

---

## 总结

`JsonSaveManager` 提供了一套 **安全、稳定、可维护的 JSON 持久化方案**：

* 以类型为入口
* 以 `[SaveKey]` 作为稳定存档标识
* 屏蔽路径与文件系统细节

适用于 **中大型 Unity 项目** 的长期维护。
